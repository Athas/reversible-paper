\documentclass[10pt]{sigplanconf}

%%%%% YOUR PACKAGES %%%%%
\usepackage{amsmath}

%%%%% END %%%%%



\begin{document}
\conferenceinfo{DIKU workshop on Topics in Programming Languages,}{June 2011.} 



%%%%% YOUR TITLE %%%%%
\title{Reversible programming constructs in a non-reversible programming language}
%\subtitle{Subtitle Text, if any}

%%%%% YOUR NAMES %%%%%
\authorinfo{Troels Henriksen \and Philip Carlsen}
           {DIKU, Department of Computer Science, University of Copenhagen}
           {athas@sigkill.dk \and plcplc@gmail.com}
%\authorinfo{Name3}
%           {Affiliation3}
%           {Email3}

\maketitle


%%%%% YOUR ABSTRACT %%%%%
\begin{abstract}
  We investigate the embedding of reversible fragments in a
  non-reversible general-purpose programming language, with the
  primary motivation being the expressivity provided by the guarantees
  of reversibility, not the possibility of execution on reversible
  hardware.  We make use of the type system to enforce separation of
  reversible and nonreversible functions.
\end{abstract}


%%%%% YOUR KEYWORDS %%%%%
% 3 to 5 general words (or topics like "reversible computing") that relates most to the content.
\keywords
reversible computing, haskell, domain-specific language, quantum computing, lambda calculus


%%%%% YOUR CONTENT %%%%%
\section{Introduction}

Reversible circuits hold the promise of fundamentally improving the
energy efficiency of computers, and much effort has been spent on
constructing physical devices capable of performing computation in
reverse.  In parallel, programming languages for the writing of
reversible programs have been developed, although they have not yet
seen much traction for general-purpose programming.  We conjecture
that one part of the reason may be that fully reversible programs can
be somewhat cumbersome to write, and that reversible computers have
not yet materialised to a degree that the effort is rewarded by the
promises of lower power consumption.  On the other hand,
\cite{YokoyamaGlueck:2007:Janus} shows, by the development of a
program for simulating the Schr√∂dinger equation, that reversible
computation can have immediate benefits even on conventional hardware.
Furthermore, investigations into reversible algorithms may benefit
from being able to leverage those properties of existing languages
(such as data types) that are orthogonal to reversibility.  We show
how reversible constructs can be embedded in a general-purpose
nonreversible language, inspired by reversible quantum operations in a
library for doing quantum computing in Haskell, the tradeoffs
necessary for the technique to be efficient (ie. avoiding a full
computation history), and compare the result to Janus.

\section{Section 2}
Reversible computing is interesting and builds on work by Bennett~\cite{Bennett:1982}. Applications of these principles can be found in~\cite{ThomsenAxelsen:2009:PPL,YokoyamaGlueck:2007:Janus}.

\subsection{A subsection}


\subsubsection{A subsubsection}

\section{Embedded reversible computation in Haskell}

As part of the quantum computing library, QIO, presented in
\cite{altenkirchquantum}, a facility for expressing reversible
(\textit{unitary}) is presented.  QIO models reversible computations
as monoids of operations that change the state of the (quantum)
machine, with the identity element being an empty computation, and the
binary operation being sequential computation.  A discussion of
quantum computing is outside the scope of this paper, and we will
restrict ourselves to those parts of QIO that are relevant to the
subject of embedded reversible computing.

The QIO model is close to the one promoted by Janus, and in turn to
reversible hardware itself, although this does not make it much more
realistic to port the library to run on real reversible hardware (as
it is still heavily dependent on the underlying Haskell runtime).  In
this model, the data size (intuitively, number of variables) is
static, and the program is a transformation from one assignment of
values to another.  Although somewhat cumbersome to program, this is
the approach chosen by Janus, and as it seems to be the most
well-understood method in the literature, we choose to preserve it in
our own library.

A number of primitive operations are provided, including negation (for
qbits), introducing local variables, and performing conditional
branching.  In order for the latter to be reversible, neither branch
may change the state used in the conditional, a limitation born from
the choice to use neither computation history or postconditional
assertions in the branch.  This is a serious limitation on the power
of the reversible language, and while it may be acceptable in a
subpart of a greater whole (such as the whole quantum computing
library), we cannot accept such a limitation.

\section{Conclusion}




%%%%% YOUR ACKNOWLEDGEMENTS %%%%%
\acks
Acknowledgments, if needed.



%%%%% YOUR BIBLIOGRAPHY %%%%%
\bibliographystyle{abbrvnat}
% The file where you have bibliography: bibliography.bib
\bibliography{bibliography}

%%%%% YOUR APPENDIX %%%%%
\appendix
\section{Appendix Title}

This is the text of the appendix, if you need one.



\end{document}

\documentclass[10pt]{sigplanconf}

%%%%% YOUR PACKAGES %%%%%
\usepackage{amsmath}
\usepackage[utf8x]{inputenc}

%%%%% END %%%%%



\begin{document}
\conferenceinfo{DIKU workshop on Topics in Programming Languages,}{June 2011.} 



%%%%% YOUR TITLE %%%%%
\title{Reversible programming constructs in a non-reversible programming language}
%\subtitle{Subtitle Text, if any}

%%%%% YOUR NAMES %%%%%
\authorinfo{Troels Henriksen \and Philip Carlsen}
           {DIKU, Department of Computer Science, University of Copenhagen}
           {athas@sigkill.dk \and plcplc@gmail.com}
%\authorinfo{Name3}
%           {Affiliation3}
%           {Email3}

\maketitle


%%%%% YOUR ABSTRACT %%%%%
\begin{abstract}
  We investigate the embedding of reversible fragments in a
  non-reversible general-purpose programming language, with the
  primary motivation being the expressivity provided by the guarantees
  of reversibility, not the possibility of execution on reversible
  hardware.  We make use of the type system to enforce separation of
  reversible and nonreversible functions.
\end{abstract}


%%%%% YOUR KEYWORDS %%%%%
% 3 to 5 general words (or topics like "reversible computing") that relates most to the content.
\keywords
reversible computing, haskell, domain-specific language, quantum computing, lambda calculus


%%%%% YOUR CONTENT %%%%%
\section{Introduction}

Reversible circuits hold the promise of fundamentally improving the
energy efficiency of computers, and much effort has been spent on
constructing physical devices capable of performing computation in
reverse.  In parallel, programming languages for the writing of
reversible programs have been developed, although they have not yet
seen much traction for general-purpose programming.  We conjecture
that one part of the reason may be that fully reversible programs can
be somewhat cumbersome to write, and that reversible computers have
not yet materialised to a degree that the effort is rewarded by the
promises of lower power consumption.  On the other hand,
\cite{YokoyamaGlueck:2007:Janus} shows, by the development of a
program for simulating the Schr√∂dinger equation, that reversible
computation can have immediate benefits even on conventional hardware.
We investigate how reversible constructs have been embedded in a
general-purpose nonreversible language, specifically reversible
quantum operations in a library for doing quantum computing in
Haskell, the tradeoffs necessary for the technique to be efficient
(ie. avoiding a full computation history), and compare the result to
Janus.

\section{Section 2}
Reversible computing is interesting and builds on work by
Bennett~\cite{Bennett:1982}. Applications of these principles can be found
in~\cite{ThomsenAxelsen:2009:PPL,YokoyamaGlueck:2007:Janus}.


\section{A reversible $\lambda$-calculus}
\cite{huelsbergen1996logically} defines the lambda calculus equivalent of a
turing machine with a history tape, by means of a lambda calculus interpreter
machine called SECD-H, written in SML.

SECD-H is structured such that no parts of it ever irreversibly erases any
data, and because of this it is argued that is holds the potential of being a
way to execute execute lambda calculus programs on reversible hardware without
emission of heat due to information erasure.
This is acheived by logging the entire execution history.

If this were to be used as a reversible component in an otherwise
non-reversible programming language, one would either have to store the
execution history together with the result of the reversible computation in
order to be able to later reconstruct the initial state, or just reverse the
history straight away to free the space used by the history log. The latter
option will probably be more desirable in most cases, as the initial arguments
are always available unless specifically thrown away, and the history must
contain the initial arguments as well. Thus, the advantages of this approach
are that of being able to run lambda calculus programs (and by extension, also
programs in most functional languages) without releasing heat from information
erasure on hardware that supports it, at the expense of a guaranteed overhead
in terms of both space and time of at least a factor of two.

\section{Embedded reversible computation in Haskell}

As part of the quantum computing library, QIO, presented in
\cite{altenkirchquantum}, a facility for expressing reversible
(\textit{unitary}) is presented.  QIO models reversible computations
as monoids of operations that change the state of the (quantum)
machine, with the identity element being an empty computation, and the
binary operation being sequential computation.  A discussion of
quantum computing is outside the scope of this paper, and we will
restrict ourselves to those parts of QIO that are relevant to the
subject of embedded reversible computing.

A number of primitive operations are provided, including negation (for
qbits - we can consider them standard booleans), introducing local
variables, and performing conditional branching.  In order for the
latter to be reversible, neither branch may change the state used in
the conditional, a limitation born from the choice to use neither
computation history or postconditional assertions in the branch.  This
is a serious limitation on the power of the reversible language, and
while it may be acceptable in a subpart of a greater whole (such as
the whole quantum computing library), we cannot accept such a
limitation.

\section{Conclusion}




%%%%% YOUR ACKNOWLEDGEMENTS %%%%%
\acks
Acknowledgments, if needed.



%%%%% YOUR BIBLIOGRAPHY %%%%%
\bibliographystyle{abbrvnat}
% The file where you have bibliography: bibliography.bib
\bibliography{bibliography}

%%%%% YOUR APPENDIX %%%%%
\appendix
\section{Appendix Title}

This is the text of the appendix, if you need one.



\end{document}
